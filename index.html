<!DOCTYPE html>
<html>
<head>
    <title>Assembly</title>
    <!-- <style type="text/css"></style> -->
    <script src="https://code.iconify.design/1/1.0.2/iconify.min.js"></script>
    <script src="jquery-3.3.1.min.js"></script>
    <!-- <script src="peg-0.10.0.min.js"></script> -->
    <script src="codemirror/codemirror.js"></script>
    <link rel="stylesheet" href="codemirror/codemirror.css">
    <link rel="stylesheet" href="codemirror/vscdark.css">
    <script src="codemirror/simple.js"></script>
    <script src="codemirror/mins.js"></script>
    <script src="assembler.js"></script>
    <script src="parser.js"></script>
    <script src="cpu.js"></script>
    <style type="text/css">
        body{
            margin: 0px;
            height: 100vh;
        }

        #editor{
            width: 100%;
            height: 100%;
            border-spacing: 0px;
        }

        #toolbar{
            height: 40px;
            background-color: #212121;
        }

        #editarea{
            padding: 0px;
            width: 100vw;
        }

        #console{
            background-color: #1a1a1a;
            border-top: 1px solid #808080;
            padding: 0px;
            vertical-align: top;
            height: 150px;
            /*position: relative;*/
        }

        #console_pre{
            color: white;
            padding: 0px;
            margin: 0px;
            height: 150px;
            width: 100vw;
            max-height: 150px;
            font-size: 14px;
            overflow-y: scroll;
            overflow-wrap: break-word;
            /*word-wrap: break-word;*/
            /*word-break: break-all;*/
            /*display: inline-block;*/
            /*max-width: 100vw;*/
            white-space: pre-wrap;
        }

        #consolebar{
            /*width: 100vw;*/
            color: white;
            background-color: #212121;
            padding: 1px 0px;
            height: 20px;
           /* position: absolute;
            top: -25px;
            right: 0px;
            width: 20px;
            z-index: 100;*/
        }

        .consbutton{
            display: inline-block;
            color: white;
            box-sizing: border-box;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .consbutton:hover{
            background-color: #313131;
        }

        .iconify{
            font-size: 20px;
            position: relative;
        }

        .button{
            display: inline-block;
            color: white;
            font-size: 14px;
            font-family: "Roboto", sans-serif;
            padding: 12px;
            height: 40px;
            box-sizing: border-box;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .button:hover{
            background-color: #313131;
        }

        .button[disabled="1"]{
            color: #626262;
        }

        #savebutton[active="true"]{
            border-bottom: 2px solid white;
        }

        #savebutton[active="false"]{
            color: #626262;
        }

        ::-webkit-scrollbar {
          width: 10px;
          height: 20px;
        }

        /* Track */
        ::-webkit-scrollbar-track {
          background: #a1a1a1; 
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
          background: #666; 
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
          background: #444; 
        }
    </style>
</head>
<body>    
    <table id='editor'>
        <tr id="toolbar"><td style="padding: 0px;">
            <div class='button' onclick="build()">
                <span class="iconify" data-icon="typcn:cog" data-inline="false" style="top: -2px;"></span>    
                <span style="vertical-align: top;">Build</span>
            </div>
            <div class='button' id="runbutton" onclick="runcode()">
                <span class="iconify" data-icon="typcn:media-play" data-inline="false" style="top: -2px;"></span>
                <span style="vertical-align: top;">Run</span>
            </div>
            <div class='button' id="savebutton" onclick="savecode()">
                <span class="iconify" data-icon="typcn:document-text" data-inline="false" style="top: -2px;"></span>
                <span style="vertical-align: top;">Save</span>
            </div>
        </td></tr>
        <tr style="padding: 0px;">
            <td id='editarea'></td>
        </tr>
        <tr style="padding: 0px;">
            <td id="console">
                <div id='consolebar'>
                    <div onclick="term.innerHTML = ''">
                        <span class="iconify consbutton" data-icon="typcn:cancel" data-inline="false"></span>
                    </div>
                </div>
                <pre id="console_pre"></pre>
            </td>
        </tr>
    </table>
    <script type="text/javascript">
        editor = CodeMirror($('#editarea')[0],{
            value: "",
            mode:  "mins",
            lineNumbers: true,
            gutters: ["CodeMirror-linenumbers", "breakpoints"],
            theme: "vscode-dark",
        });

        editor.on("gutterClick", function(cm, n) {
            var info = cm.lineInfo(n);
            if(info.gutterMarkers){
                cm.setGutterMarker(n, "breakpoints", null);
                for (var i = breakpoints.length - 1; i >= 0; i--) {
                    if(breakpoints[i]==info.line) breakpoints.splice(i,1)
                }
            }else{
                cm.setGutterMarker(n, "breakpoints", makeMarker());
                breakpoints.push(info.line)
            }
        });

        editor.on("change",function (cm) {
            $("#savebutton")[0].setAttribute("active",'true');
        })

        if(localStorage.getItem('cm_code')!=null){
            editor.getDoc().setValue(localStorage.getItem('cm_code'));
            $("#savebutton")[0].setAttribute("active",'false');
        }

        function makeMarker() {
          var marker = document.createElement("div");
          marker.style.color = "#822";
          marker.innerHTML = "‚óè";
          return marker;
        }

        breakpoints = []
        mem_breakpoints = []
        macros = {}
        mach = ""

        running = false
        function runcode() {
            if(!running){
                running = true
                //$("#runbutton svg")[0].setAttribute("data-icon","typcn:media-stop")
                //$("#runbutton span")[0].innerHTML = "Stop"
                $("#runbutton")[0].setAttribute("disabled",1);
                svm.loadHex(mach)
                svm.set_reg(14,256)
                svm.set_reg(15,0)
                svm.set_flag(3,0)
                for (var i = 1; i < 13; i++) {
                    svm.set_reg(i,0)
                }
                svm.set_reg()
                //while(!svm.get_reg(3)){
                //    console.log(svm.get_reg(14))
                //    svm.step()
                //}
                id = setTimeout(()=>{
                    //console.log(svm.get_reg(14))
                    //svm.step()
                    //if(svm.get_flag(3)) clearInterval(id)
                    while(!svm.get_flag(3)){
                        svm.step()
                    }
                    $("#runbutton")[0].setAttribute("disabled",0);
                    running = false
                },0)
            }
        }

        function savecode() {
            localStorage.setItem('cm_code', editor.getValue());
            $("#savebutton")[0].setAttribute("active",'false');
        }

        asmer = new Assembler()
        svm = new VirtualMachine()
        svm.set_reg(14,0x100)

        term = document.getElementById("console_pre")
        function terminal(s) {
            term.innerHTML += s
            term.scrollTop = term.scrollHeight;
        }

        function Error(e){
            term.innerHTML += "<span style='color: red'>"+("Error: Line " + (asmer.line+1)+ ': ' + e)+"\n</span>"
            term.scrollTop = term.scrollHeight;
            throw "Line " + (asmer.line+1)+ ': ' + e;
        }

        function Warn(e) {
            term.innerHTML += "<span style='color: lightblue'>"+("Warning: Line " + (asmer.line+1)+ ': ' + e)+"\n</span>"
            term.scrollTop = term.scrollHeight;
        }

        function build() {
            savecode();
            //localStorage.setItem('cm_code', editor.getValue());
            let t0 = performance.now();
            mach = asmer.assemble(editor.getValue())
            //terminal(mach+'\n')
            let t1 = performance.now();
            terminal("Build finished in "+((t1-t0)/1000).toFixed(3)+"s\n\n")
        }

        /*function byteOp(op1,op2) {
            if(op1.type!='reg' || op2.type!='reg') Error('Invalid Register Operand')
            return new Operand('pair',op1.value*16+op2.value)
        }

        function W2B(w){
            return [(w & 0xff00) >> 8,w & 0x00ff]
        }

        line = 0
        function Error(string) {
            $('#error').html((line+1)+': '+string)
            $('#error').css('display','inline')
            throw string
        }

        function operandError(inst,op1,op2,op3) {
            er1 = op1.type!='null' ? ' '+op1.type : ''
            er2 = op2.type!='null' ? ', '+op2.type : ''
            er3 = op3.type!='null' ? ', '+op3.type : ''
            Error('Invalid Operand(s) for '+inst+': '+er1+er2+er3)
        }

        function CompileError(string) {
            $('#error').html(string)
            $('#error').css('display','inline')
            throw string
        }

        function assemble() {
            $('#error').html('')
            $('#error').css('display','none')

            code = editor.getValue()

            localStorage.setItem('cm_code', code);

            code = code.split('\n')

            labels = {}

            mem = []
            mem_breakpoints = []
            asmpc = 0
            line = 0
            macro_count = 0

            function store(size,op,...data) {
                mem.push(op)
                mem.push(...data)
                asmpc += size
            }

            set_continue = false
            macro_code = []
            macro_name = ''
            for (var i = 0; i < code.length; i++) {
                if(!code[i]) continue
                line = i


                inst = code[i].match(/^[\t ]*(?:([a-z_\d]*)[:])?(?:\s*(.?[a-z]+)(?:[\t ]+(.*))?)?/i)

                if(set_continue && inst[2]!='.endmacro'){
                    macro_code.push(code[i])
                    continue;
                }

                //if(line == 57){console.log(asmpc)}
                for (var bp = 0; bp < breakpoints.length; bp++) {
                    if(line == breakpoints[bp]) mem_breakpoints.push(asmpc)
                }
                
                if(inst[1]){
                    labels[inst[1]] = asmpc+256
                }

                if(inst[3]){
                    ops = parseOps(inst[3])
                    op1 = ops[0]!=undefined ? ops[0] : new Operand('null',0)
                    op2 = ops[1]!=undefined ? ops[1] : new Operand('null',0)
                    op3 = ops[2]!=undefined ? ops[2] : new Operand('null',0)

                    if(op3.type=='reg') r2 = op3
                    else r2 = new Operand('reg',0)
                }else{ops=[]}

                if(inst[2]!=undefined){
                    if(inst[2][0]==';') continue
                    switch(inst[2]){
                    case 'mov':
                        if(op1.type=='reg'){
                            console.log(ops)
                            /*
                            mov r1, I{, r2}
                            mov r1, M/L{, r2}
                            mov r1, r2
                            mov r1, [r2{+I}]
                            mov r1, (M/L),r2
                            *-/
                            if(op2.type=='imm') store(3,Opcodes.mov_r_i,byteOp(op1,r2),op2)
                            else if(op2.type=='mem') store(4,Opcodes.mov_r_m,byteOp(op1,r2),op2)   
                            else if(op2.type=='reg') store(3,Opcodes.mov_r_i,byteOp(op1,op2),new Operand('imm',0,'int'))
                            else if(op2.type=='regadd') store(3,Opcodes.mov_r_zp,byteOp(op1,new Operand('reg',op2.value[0])),new Operand('imm',op2.value[1]))
                            else if(op2.type=='ind'){
                                console.log(op2)
                                store(3,Opcodes.mov_r_d,
                                    byteOp(op1,new Operand('reg',op2.value[1])),
                                    new Operand('imm',op2.value[0],op2.value[2]))
                            }
                            //else if(op2.type=='label') store(4,Opcodes.mov_r_m,byteOp(op1,r2),op2)
                            else operandError(inst[2],op1,op2,op3)
                        }else if(op1.type=='mem' || op1.type=='label'){
                            /*
                            mov M/L, I
                            mov M/L, r1{, r2}
                            *-/
                            if(op2.type=='imm') store(4,Opcodes.mov_m_i,op2,op1)
                            else if(op2.type=='reg') store(4,Opcodes.mov_m_r,byteOp(op2,r2),op1)
                            else operandError(inst[2],op1,op2,op3)
                        }else if(op1.type=='regadd' && op2.type=='reg'){
                            /*
                            mov [r1{+I}], r2
                            *-/
                            store(3,
                                Opcodes.mov_r_r,
                                byteOp(op2,new Operand('reg',op1.value[0])),
                                new Operand('imm', op1.value[1]))
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'add':
                        /*
                        add r1, M{, r2}
                        add r1, I{, r2}
                        *-/
                        if(op1.type=='reg'){
                            if(op2.type=='mem'){
                                store(4,Opcodes.add_r_m,byteOp(op1,r2),op2)
                            }else if(op2.type=='imm'){
                                store(3,Opcodes.add_r_i,byteOp(op1,r2),op2)
                            }else operandError(inst[2],op1,op2,op3)
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'inc':
                        /*
                        inc r1
                        *-/
                        if(op1.type=='reg'){
                            store(2,Opcodes.inc,byteOp(op1,new Operand('reg', 0)))
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'sub':
                        /*
                        sub r1, M{, r2}
                        sub r1, I{, r2}
                        *-/
                        if(op1.type=='reg'){
                            if(op2.type=='mem'){
                                store(4,Opcodes.sub_r_m,byteOp(op1,r2),op2)
                            }else if(op2.type=='imm'){
                                store(3,Opcodes.sub_r_i,byteOp(op1,r2),op2)
                            }else operandError(inst[2],op1,op2,op3)
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'dec':
                        /*
                        dec r1
                        *-/
                        if(op1.type=='reg'){
                            store(2,Opcodes.dec,byteOp(op1,new Operand('reg', 0)))
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'jmp':
                        /*
                        jmp M/L
                        *-/
                        if(op1.type=='mem') store(3,Opcodes.jmp,op1)
                        //else if(op1.type=='label') store(3,Opcodes.jmp,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'jsr':
                        /*
                        jsr M/L
                        *-/
                        if(op1.type=='mem') store(3,Opcodes.jsr,op1)    
                        //else if(op1.type=='label') store(3,Opcodes.jsr,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'rts':
                        store(1,Opcodes.rts)
                        break;
                    case 'cmp':
                        if(op2.type=='imm') store(3,Opcodes.cmp_r_i,byteOp(op1,r2),op2)
                        else if(op2.type=='mem') store(4,Opcodes.cmp_r_m,byteOp(op1,r2),op2)
                        else if(op2.type=='reg') store(2,Opcodes.cmp_r_r,byteOp(op1,op2))
                        //else if(op2.type=='label') store(4,Opcodes.cmp_r_m,byteOp(op1,r2),op2)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'beq':
                        if(op1.type=='mem') store(3,Opcodes.beq,op1)
                        //else if(op1.type=='label') store(3,Opcodes.beq,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'bne':
                        if(op1.type=='mem') store(3,Opcodes.bne,op1)
                        //else if(op1.type=='label') store(3,Opcodes.bne,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'blt':
                        if(op1.type=='mem') store(3,Opcodes.blt,op1)
                        //else if(op1.type=='label') store(3,Opcodes.blt,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'bge':
                        if(op1.type=='mem') store(3,Opcodes.bge,op1)
                        //else if(op1.type=='label') store(3,Opcodes.bge,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'ble':
                        if(op1.type=='mem') store(3,Opcodes.ble,op1)
                        //else if(op1.type=='label') store(3,Opcodes.ble,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'bgt':
                        if(op1.type=='mem') store(3,Opcodes.bgt,op1)
                        //else if(op1.type=='label') store(3,Opcodes.bgt,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'bcs':
                        if(op1.type=='mem') store(3,Opcodes.bcs,op1)
                        else if(op1.type=='label') store(3,Opcodes.bcs,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'bcc':
                        if(op1.type=='mem') store(3,Opcodes.bcc,op1)
                        //else if(op1.type=='label') store(Opcodes.bcc,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'and':
                        if(op1.type=='reg'){
                            if(op2.type=='imm'){
                                store(3,Opcodes.and_r_i,byteOp(op1,new Operand('reg', 0)),op2)
                            }else if(op2.type=='reg'){
                                store(3,Opcodes.and_r_i,byteOp(op1,op2),new Operand('imm',0))
                            }else if(op2.type=='mem'){
                                store(4,Opcodes.and_r_m,byteOp(op1,r2),op2)
                            }else operandError(inst[2],op1,op2,op3)
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'or':
                        if(op1.type=='reg'){
                            if(op2.type=='imm'){
                                store(3,Opcodes.or_r_i,byteOp(op1,new Operand('reg', 0)),op2)
                            }else if(op2.type=='reg'){
                                store(3,Opcodes.or_r_i,byteOp(op1,op2),new Operand('imm',0))
                            }else if(op2.type=='mem'){
                                store(4,Opcodes.or_r_m,byteOp(op1,r2),op2)
                            }else operandError(inst[2],op1,op2,op3)
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'xor':
                        if(op1.type=='reg'){
                            if(op2.type=='imm'){
                                store(3,Opcodes.xor_r_i,byteOp(op1,new Operand('reg', 0)),op2)
                            }else if(op2.type=='reg'){
                                store(3,Opcodes.xor_r_i,byteOp(op1,op2),new Operand('imm',0))
                            }else if(op2.type=='mem'){
                                store(4,Opcodes.xor_r_m,byteOp(op1,r2),op2)
                            }else operandError(inst[2],op1,op2,op3)
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'not':
                        if(op1.type=='reg'){
                            store(2,Opcodes.not,byteOp(op1,new Operand('reg', 0)))
                        }else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'clc':
                        store(1,Opcodes.clc)
                        break;
                    case 'sec':
                        store(1,Opcodes.sec)
                        break;
                    case 'psh':
                        if(op1.type=='mem') store(3,Opcodes.psh_m,op1)
                        else if(op1.type=='imm') store(2,Opcodes.psh_i,op1)
                        else if(op1.type=='reg') store(2,Opcodes.psh_r,byteOp(op1,new Operand('reg', 0)))
                        else if(op1.type=='label') store(3,Opcodes.psh_m,op1)
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'pop':
                        if(op1.type=='reg') store(2,Opcodes.pop,byteOp(op1,new Operand('reg',0)))
                        else if(op1.type=='label') store(2,Opcodes.pop,byteOp(new Operand('reg',15),new Operand('reg',0)))
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'shr':
                        if(op1.type=='reg' && op2.type=='imm') store(2,Opcodes.shr,byteOp(op1,new Operand('reg', (op2.value-1)%16)))
                        else if(op1.type=='reg') store(2,Opcodes.shr,byteOp(op1,new Operand('reg', 0)))
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'shl':
                        if(op1.type=='reg' && op2.type=='imm') store(2,Opcodes.shl,byteOp(op1,new Operand('reg', (op2.value-1)%16)))
                        else if(op1.type=='reg') store(2,Opcodes.shl,byteOp(op1,new Operand('reg', 0)))
                        else operandError(inst[2],op1,op2,op3)
                        break;
                    case 'brk':
                        store(1,0)
                        break;
                    case '.data':
                        data = parseData(ops)
                        mem = mem.concat(data)
                        asmpc += data.length
                        break;
                    case '.zeros':
                        size = ops[0].value
                        mem = mem.concat(new Array(size).fill(0))
                        asmpc += size
                        break;
                    case '.def':
                        labels[op1.value] = op2.value
                        break;
                    case '.include':
                        mem = mem.concat(include_sr[op1.value])
                        labels[op1.value] = asmpc
                        asmpc += include_sr[op1.value].length
                        break;
                    case '.macro':
                        //console.log(ops)
                        set_continue = true
                        macro_ops = ops
                        break;
                    case '.endmacro':
                        //console.log(macro_code)
                        macros[macro_ops[0].value] = {code:macro_code,params:macro_ops}
                        macro_code = []
                        macro_ops = []
                        set_continue = false
                        break;
                    case '.inclbl':
                        labels[op1.value] += op2.value
                        break;
                    case '.declbl':
                        labels[op1.value] -= op2.value
                        break;
                    default:
                        if(macros.hasOwnProperty(inst[2])){
                            //console.log(ops)
                            Pmacro_code = ParseMacro(macros[inst[2]],ops)
                            code = code.slice(0,i).concat(Pmacro_code.concat(code.slice(i+1)))
                        }else{
                            Error('Invalid Opcode: '+inst[2])
                        }
                    }
                }
            }

            //console.log(mem)
            mcode = ''
            for (var i = 0; i < mem.length; i++) {
                if(isNaN(mem[i])){
                    if(mem[i].type=='label'){
                        if(labels[mem[i].value]==undefined) CompileError('Undefined label '+mem[i].value)
                        word = W2B(labels[mem[i].value])
                        mcode += String.fromCharCode(word[0])
                        mcode += String.fromCharCode(word[1])
                    }else if(mem[i].type=='imm'){
                        if(isNaN(mem[i].value) || mem[i].form=='string' || mem[i].form=='const'){
                            if(mem[i].form=='const'){
                                if(labels[mem[i].value]==undefined) CompileError('Undefined label '+mem[i].value)
                                mcode += String.fromCharCode(labels[mem[i].value])
                            }else{
                                mcode += String.fromCharCode(mem[i].value.charCodeAt(0))
                            }
                        }else if(mem[i].value<256 && mem[i].value>=0  || mem[i].form=='int'){
                            mcode+= String.fromCharCode(mem[i].value)
                        }else{
                            CompileError('Error compiling Number')
                        }
                    }else if(mem[i].type=='mem'){
                        if(isNaN(mem[i].value) || mem[i].form=='label'){
                            word = W2B(labels[mem[i].value])
                            mcode += String.fromCharCode(word[0])
                            mcode += String.fromCharCode(word[1])
                        }else{
                            word = W2B(mem[i].value)
                            mcode += String.fromCharCode(word[0])
                            mcode += String.fromCharCode(word[1])
                        }
                    }else if(mem[i].type=='pair'){
                        mcode+= String.fromCharCode(mem[i].value)
                    }else if(mem[i].type=='_'){
                    }else if(mem[i].type=='off'){
                        pos = mcode.length+256
                        word = W2B(pos+mem[i].value)
                        mcode += String.fromCharCode(word[0])
                        mcode += String.fromCharCode(word[1])
                    }else{
                        CompileError('Error compiling operand '+mem[i].type)
                    }
                }else{
                    if(mem[i]>255){
                        CompileError('Error compiling number')
                    }else
                        mcode+= String.fromCharCode(mem[i])
                }
            }

            if(mcode){
                $('#exec').prop('disabled',false)
            }

            console.log(encodeURI(mcode))
            //output = encodeURI(JSON.stringify({code:mcode,bp:breakpoints}))
            //console.log(output)
            //console.log( JSON.parse(decodeURI(output) ))
            //console.log(mcode)
        }*/
    </script>
</body>
</html>